package Spell
import public ObjEditingNatives
import LinkedList
import DamageEvent
import ClosureEvents

public interface DamageFilterClosure
  function check(unit source, unit target) returns bool

public constant DamageFilterClosure STD_DFC_CLOSURE = (s, t) -> t.isAlive() and s.isEnemyOf(t) and not t.isType(UNIT_TYPE_STRUCTURE) and not t.isType(UNIT_TYPE_MAGIC_IMMUNE)

public interface DamageLevelClosure
  function run(int lvl, real spellpower) returns real
/**
abstract function onSpellEffect(unit caster)

abstract function onSpellEffect(unit caster, unit target)

abstract function onSpellEffect(unit caster, vec2 pos)
*/

public function stdEnemyCheck(unit u) returns bool
  return u.isAlive() and not u.isType(UNIT_TYPE_MAGIC_IMMUNE) and not u.isType(UNIT_TYPE_STRUCTURE)

public function stdEnemyFilter() returns bool
  return stdEnemyCheck(GetFilterUnit())

public abstract class Spell
  static let list = new LinkedList<Spell>
  protected int id

  construct(int newid)
    id = newid
    list.add(this)

  function damageTarget(unit source, unit target, real dmgamount, damagetype dmgtype/*, DamageFilterClosure dfc*/)
    //if dfc.check(source, target)
    DamageEvent.setNextDamageFromCode()
    DamageEvent.setNextDamageId(this.id)
    source.damageTarget(target, dmgamount, true, false, ATTACK_TYPE_MAGIC, dmgtype, WEAPON_TYPE_WHOKNOWS)
