package RecentDamage
import BloodWarOverall
import HeroEntity
import HashMap
import LinkedList
import TimerUtils
import PlayerData

import DamageEvent


class RecentDamage
  static let map = new IterableMap<HeroEntity, thistype>
  HeroEntity victim
  IterableMap<PlayerData, real> remainTimeList         // <attacker, time>
  static let waitingTime = 10.
  static timer checkTimer
  static bool timerToDestroy


  construct(HeroEntity vic)
    if not map.has(vic)
      victim = vic
      remainTimeList = new IterableMap<PlayerData, real>
      map.put(vic, this)

      DamageEvent.addListener(DAMAGE_EVENT_PRIO_FINAL) ->
        if DamageEvent.getAmount() > 0
          let target = DamageEvent.getTarget()
          let source = DamageEvent.getSource()

          let sourcePlayer = source.getPlayerData()
          let rdelement = map.get(HeroEntity.get(target))
          if rdelement != null
            rdelement.remainTimeList
              ..remove(sourcePlayer)
            ..put(sourcePlayer, waitingTime)

            if checkTimer == null
              checkTimer = getTimer()
              ..startPeriodic(0.1) ->
                timerToDestroy = true
                map.forEach() (vic, RecentDamage value) ->
                  value.remainTimeList.forEach() (source, time) ->
                    let newtime = time - 0.1
                    if newtime <= 0
                      value.remainTimeList.remove(source)
                      if value.remainTimeList.size() != 0 and timerToDestroy
                        timerToDestroy = false

                    else
                      value.remainTimeList.put(source, newtime)
                      timerToDestroy = false
                if timerToDestroy
                  checkTimer.release()
                  checkTimer = null

  static function attackers(HeroEntity vic) returns LinkedList<PlayerData>
    var outputList = new LinkedList<PlayerData>
    for pd in map.get(vic).remainTimeList
      outputList.add(pd)
    if outputList.size() == 0
      destroy outputList
      return null
    return outputList


  static function isHeroDamaged(HeroEntity he) returns bool
    if map.has(he)
      if map.get(he).remainTimeList.size() > 0
        return true
    return false//DamageTaking.timerList.get(he) != null

  static function attackersLevel(HeroEntity victim) returns int
    let attackers = RecentDamage.attackers(victim)
    //attackers.removeIf( (t) -> t.actor.isAllyOf(victim.actor) )
    int toplevel = 1
    for a in attackers
      //var lvl = a.actor.getLevel()
      //if lvl > toplevel
      //  toplevel = lvl
    return toplevel

  static function initlialize()
    for u in HeroEntity.list
      new RecentDamage(HeroEntity.list.get(u))
