package RecentDamage

import HeroEntity
import HashMap
import LinkedList
import TimerUtils
import PlayerData

import DamageEvent


class RecentDamage
  static let map = new IterableMap<HeroEntity, thistype>
  HeroEntity victim
  IterableMap<HeroEntity, real> remainTimeList         // <attacker, time>
  static let waitingTime = 10.
  static timer checkTimer
  static bool timerToDestroy


  construct(HeroEntity vic)
    if not map.has(vic)
      victim = vic
      remainTimeList = new IterableMap<HeroEntity, real>
      map.put(vic, this)
      DamageEvent.addListener(5) ->
        if DamageEvent.getTarget() == vic.actor and DamageEvent.getAmount() > 0
          let source = HeroEntity.list.get(DamageEvent.getSource())
          var t = map.get(vic).remainTimeList
          t.remove(source)
          t.put(source, waitingTime)

          if checkTimer == null
            checkTimer = getTimer()
            ..startPeriodic(0.1) ->
              timerToDestroy = true
              map.forEach() (vic, RecentDamage value) ->
                value.remainTimeList.forEach() (source, time) ->
                  let newtime = time - 0.1
                  if newtime <= 0
                    value.remainTimeList.remove(source)
                    if value.remainTimeList.size() != 0 and timerToDestroy
                      timerToDestroy = false

                  else
                    value.remainTimeList.put(source, newtime)
                    timerToDestroy = false
              if timerToDestroy
                checkTimer.release()
                checkTimer = null

  static function attackers(HeroEntity vic) returns LinkedList<HeroEntity>
    var outputList = new LinkedList<HeroEntity>
    for he in map.get(vic).remainTimeList
      outputList.add(he)
    if outputList.size() == 0
      destroy outputList
      return null
    return outputList


  static function isHeroDamaged(HeroEntity he) returns bool
    if map.has(he)
      if map.get(he).remainTimeList.size() > 0
        return true
    return false//DamageTaking.timerList.get(he) != null


  static function attackerPlayers(HeroEntity victim) returns LinkedList<PlayerData>
    let attackers = attackers(victim)
    attackers.removeIf( (t) -> t.actor.isAllyOf(victim.actor) )
    let attackerPlayers = new LinkedList<PlayerData>
    for d in attackers
      if not attackerPlayers.has(d.ownerData)
        attackerPlayers.add(d.ownerData)
    destroy attackers
    return attackerPlayers

  static function attackersLevel(HeroEntity victim) returns int
    let attackers = RecentDamage.attackers(victim)
    //attackers.removeIf( (t) -> t.actor.isAllyOf(victim.actor) )
    int toplevel = 1
    for a in attackers
      var lvl = a.actor.getLevel()
      if lvl > toplevel
        toplevel = lvl
    return toplevel

  static function initlialize()
    for u in HeroEntity.list
      new RecentDamage(HeroEntity.list.get(u))
